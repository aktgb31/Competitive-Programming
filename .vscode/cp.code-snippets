{
    "My Cp template": {
        "prefix": "cp",
        "body": [
            "/*",
            "  Created by: Amit Kumar at $CURRENT_HOUR:$CURRENT_MINUTE on $CURRENT_DATE $CURRENT_MONTH_NAME_SHORT $CURRENT_YEAR_SHORT",
            "*/",
            "#include <bits/stdc++.h>",
            "#ifdef LOCAL",
            "#include \"debug.h\"",
            "#else",
            "#define db(...)",
            "#endif",
            "using namespace std;",
            "",
            "#define ll long long",
            "#define S(x, n) memset(x, n, sizeof(x));",
            "#define pb(x) emplace_back(x)",
            "#define all(x) x.begin(),x.end()",
            "#define NIL -1",
            "",
            "const long long MAXN = 2e5 + 1;",
            "const long long mod = 1e9 + 7;",
            "",
            "template <typename T>",
            "inline istream &operator>>(istream &is, vector<T> &A);",
            "",
            "template <typename T>",
            "inline ostream &operator<<(ostream &os, vector<T> &A);",
            "",
            "void solve()",
            "{",
            "  $0 ",
            "}",
            "int32_t main()",
            "{",
            "#ifdef LOCAL",
            "    freopen(\"input.txt\", \"r\", stdin);",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "    auto started = std::chrono::high_resolution_clock::now();",
            "#endif",
            "",
            "    ios_base::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "    int t;",
            "    t = 1;",
            "    $1cin >> t;",
            "    for (int I = 1; I <= t; I++)",
            "    {",
	        "	#ifdef LOCAL",
            "cerr << \"TestCase \" << I << \"\\n\";",
            "#endif",
            "        solve();",
            "    }",
            "#ifdef LOCAL",
    		"	auto done = std::chrono::high_resolution_clock::now();",
    		"	cerr << \"Time = \" << std::chrono::duration_cast<std::chrono::milliseconds>(done - started).count() << \" ms\\n\";",
            "#endif",
            "    return 0;",
            "}",
            "template <typename T>",
            "inline istream &operator>>(istream &is, vector<T> &A)",
            "{",
            "    for (int i = 0; i < A.size(); i++)",
            "        is >> A[i];",
            "    return is;",
            "}",
            "",
            "template <typename T>",
            "inline ostream &operator<<(ostream &os, vector<T> &A)",
            " {",
            "   for (int i = 0; i < A.size(); i++)",
            "      os << A[i] << \" \";",
            "os << \"\\n\";",
            "return os;",
            "}",
        ],
        "description": "My Cp template"
    },
    "power": {
        "prefix": "pw",
        "body": [
            "long long power(long long x, long long y)",
            "{",
            "    long long res = 1;",
            "    x = x % mod;",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res * x) % mod;",
            "        y = y >> 1;",
            "        x = (x * x) % mod;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "power"
    },
    "policy based Data Structure": {
        "prefix": "pol",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "typedef tree<",
            "int, //key type",
            "null_type, // null_type for set,mapped for map",
            "less_equal<int>, // comparator",
            "rb_tree_tag, // tag denoting tree structure but not used for map",
            "tree_order_statistics_node_update>",
            "ordered_set;",
            "//1)find_by_order(k) returns element at index k (zero indexed)",
            "//2)order_of_key(element) returns the number of elements strictly smaller than element",
        ],
        "description": "Policy based Data Structure"
    },
    "for": {
        "prefix": "f",
        "body": [
            "for (size_t ${1:i} = ${2:0}; ${1:i} < ${3:length}; ${1:i}++)",
            "{",
            "$4",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${1:i} = ${2:length} - 1; ${i} >= ${3:0}; ${i}--)",
            "{",
            "$4",
            "}"
        ],
        "description": "Code snippet for reverse 'for' loop"
    },
    "cinfor": {
        "prefix": "ifor",
        "body": [
            "for (size_t ${1:i} = ${2:0}; ${i} < ${3:length}; ${i}++)",
            "{",
            "cin>>$4[${i}];",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "pair of ints": {
        "prefix": "pii",
        "body": [
            "pair<int,int>"
        ],
        "description": "Code snippet for pair of ints"
    },
    "pair of long long": {
        "prefix": "pll",
        "body": [
            "pair<long long,long long>"
        ],
        "description": "Code snippet for pair of long longs"
    },
    "2D Vector": {
        "prefix": "v2d",
        "body": [
            "vector<vector<${2:int}>>$3($4,vector<${2:int}>($5,$1));",
            "$0"
        ],
        "description": "2d vector"
    },
    "ncr": {
        "prefix": "ncr",
        "body": [
            "vector<ll> fact(MAXN);",
            "vector<ll> inv_fact(MAXN);",
            "",
            "void build_fact()",
            "{",
            "    fact[0] = 1;",
            "    for (ll i = 1; i < MAXN; i++)",
            "    {",
            "        fact[i] = (i * fact[i - 1]) % mod;",
            "    }",
            "    inv_fact[MAXN - 1] = power(fact[MAXN - 1], mod - 2);",
            "    for (ll i = MAXN - 2; i >= 0; i--)",
            "    {",
            "        inv_fact[i] = ((i + 1) * inv_fact[i + 1]) % mod;",
            "    }",
            "}",
            "ll ncr(ll n, ll r)",
            "{",
            "    static bool built = false;",
            "    if (!built)",
            "    {",
            "        build_fact();",
            "        built = true;",
            "    }",
            "    if (n < r)",
            "       return 0;",
            "     if (n < 0 || r < 0)",
            "       return 0;",
            "    return (((fact[n] * inv_fact[r]) % mod) * (inv_fact[n - r])) % mod;",
            "}"
        ],
        "description": "ncr"
    },
    "Taking pair input": {
        "prefix": "cinpair",
        "body": [
            "template <typename T,typename U>",
            "inline istream &operator>>(istream &is, pair<T,U> &A)",
            "{",
            "        is >> A.first>>A.second;",
            "    return is;",
            "}"
        ],
        "description": "Taking pair input"
    },
    "matrices": {
        "prefix": "matrices",
        "body": [
            "namespace matrixOperations",
            "{",
            "    using T = long long;",
            "#define dim(n, m) (n, vector<T>(m))",
            "    typedef vector<vector<T>> matrix;",
            "",
            "    long long matrixSum(const matrix &A)",
            "    {",
            "        long long res = 0;",
            "        for (const auto &rows : A)",
            "            for (const auto &cells : rows)",
            "                res = (res + cells);",
            "        return res;",
            "    }",
            "",
            "    inline matrix operator+(const matrix &A, const matrix &B)",
            "    {",
            "        int n = A.size(), m = A[0].size();",
            "        matrix X dim(n, m);",
            "        for (int i = 0; i < n; ++i)",
            "            for (int j = 0; j < m; ++j)",
            "            {",
            "                X[i][j] = (A[i][j] + B[i][j]);",
            "            }",
            "        return X;",
            "    }",
            "    void unit(matrix &MAT)",
            "    {",
            "        for (int i = 0; i < MAT.size(); ++i)",
            "            MAT[i][i] = 1;",
            "    }",
            "",
            "    inline matrix operator*(const matrix &A, const matrix &B)",
            "    {",
            "        int n = A.size(), m = A[0].size(), o = B[0].size();",
            "        matrix X dim(n, o);",
            "        for (int i = 0; i < n; ++i)",
            "            for (int j = 0; j < o; ++j)",
            "                for (int k = 0; k < m; ++k)",
            "                    X[i][j] = (X[i][j] + (A[i][k] * B[k][j]));",
            "",
            "        return X;",
            "    }",
            "    inline matrix power(matrix A, long long y)",
            "    {",
            "        matrix res dim(A[0].size(), A[0].size());",
            "        unit(res);",
            "        while (y > 0)",
            "        {",
            "            if (y & 1)",
            "                res = (res * A);",
            "            y = y >> 1;",
            "            A = A * A;",
            "        }",
            "        return res;",
            "    }",
            "};",
            "using namespace matrixOperations;",
            ""
        ],
        "description": "matrices"
    }
}
}